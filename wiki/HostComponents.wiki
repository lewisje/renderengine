#summary Object oriented in-game object design and programming
= Host Object Components =

As was stated in the EngineProcessOverview, host objects contain components.  Those components perform one specific function very well.  This allows a host object to segment its processing without having to handle all of the functionality itself.  Each host object need only add components to itself to gain the functionality of that component.  From the example game:
{{{
   constructor: function(size, position, pWidth, pHeight) {
      // Call the super class' constructor
      this.base("Spaceroid");

      // Add components to move and draw the asteroid
      this.add(Mover2DComponent.create("move"));
      this.add(Vector2DComponent.create("draw"));
      this.add(ColliderComponent.create("collider", Spaceroids.collisionModel));

      // Playfield bounding box for quick checks
      this.pBox = Rectangle2D.create(0, 0, pWidth, pHeight);

      // Set size and position
      this.size = size || 10;
      this.scoreValue = SpaceroidsRock.values[String(this.size)];
      if (!position)
      {
         // Set the position
         position = new Point2D( Math.floor(Math.random() * this.pBox.getDims().x),
                                 Math.floor(Math.random() * this.pBox.getDims().y));
      }
      this.setPosition(position);
   }
}}}
As you can see, a rock contains three components: one mover, one renderer, and one collider.  By doing so, the rock doesn't have to worry about where it's positioned or how it moves, nor does it have to understand how to render to the context.  We feed each component with information that it needs, and the component does the work for us.  For example, the "draw" component needs to know what points to render and how to render it:
{{{
setShape: function() {
   var c_draw = this.getComponent("draw");

   // Pick one of the three shapes
   var tmp = [];
   tmp = SpaceroidsRock.shapes[Math.floor(Math.random() * 3)];

   // Scale the shape
   var s = [];
   for (var p = 0; p < tmp.length; p++)
   {
      var pt = Point2D.create(tmp[p][0], tmp[p][1]);
      pt.mul(this.size);
      s.push(pt);
   }

   // Assign the shape to the vector component
   c_draw.setPoints(s);
   c_draw.setLineStyle("white");
   c_draw.setLineWidth(0.5);
}
}}}
We refer to components by a unique name, assigned when we added the component to the host object.  We cannot have two components with the same name, however we _can_ have two components of the same type as long as the names are different.

Once we get the component, we can call its methods to set it up.  From that point on, we don't really need to do anything unless we want to modify how it behaves.  In this case, we're done.  We only needed to set the points, tell it the color, and set the line width.  The "move" component will handle all of the positioning and rotation.  See how this works?  Pretty cool, eh?

== Callback Components ==

Some components need to interact with the host object.  Those components will call predefined methods on your host object.  The component defines the method names that you must implement.  If you don't implement the method don't worry... Components must be able to handle that situation gracefully.

The rock object has one method that it needs to implement for the collider component to be effective.  The method, as long as it is defined, will be called by the component whenever it needs to update the host object.  In this case, the rock needs to know if it has collided with the player object:
{{{
   onCollide: function(obj) {
      if (obj instanceof SpaceroidsPlayer &&
          (Math2D.boxBoxCollision(this.getWorldBox(), obj.getWorldBox())))
      {
         if (obj.isAlive())
         {
            obj.kill();
            this.kill();

            // Tell the collider component to stop
            return ColliderComponent.STOP;
         }
      }

      // Let the collider component know to keep processing
      return ColliderComponent.CONTINUE;
   }
}}}
Callback methods begin with the "on" prefix so that you know that you are responding to an event generated by a component.  `onCollide()` will be called by the collider component when potential collisions are occurring based on the collision model supplied to the component when it was initialized.  The object which is potentially colliding with the rock object is passed into the method.

It is up to us to determine if the collision is valid or not, and to respond accurately.  Not all callbacks will need to be responded to.  However, in this case, the collider component needs to know if it should continue checking for collisions this frame, or if we're satisfied that a collision has occurred.

If the object is an instance of a player object, and that object's bounding box overlaps the rock's bounding box, we say a collision has occurred.  We let the collider component know that it can stop checking for further collisions by passing `ColliderComponent.STOP`.  If this wasn't a valid collision, we tell the collider to continue so it can see if other objects are potentially colliding with the rock.

== Component Inheritance ==

The point of using an object oriented architecture is to allow classes to inherit functionality from some parent class.  For example, the `Mover2D` component inherits from the `Transform2D` component.  The reason for this is that `Transform2D` can handle position, rotation, and scale and that is what the `Mover2D` component needs.  However, `Transform2D` only stores a single position, rotation, and scale so it must be continually updated to be of much use.

`Mover2D` inherits from `Transform2D` to get access to those values, but adds the ability to update the position based on a velocity vector and update the rotation based on an  angular velocity.

== Components Example ==

[http://www.renderengine.com/tutorials/tutorial2_1.php Tutorial 2] on _The Render Engine_ website has more information on the topic.  [http://www.renderengine.com/tutorials/tutorial3_1.php Tutorial 3] shows multiple components working together in a simple HostObject.