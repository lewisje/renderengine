#summary Basic in-game objects.

= Introduction =

A game is comprised of objects which represent the game world for the player(s).  Within this game, you might have a player, enemies, projectiles, score elements, power-ups, and so on.  Each of these objects, while unique, share a common purpose:  They have to move about within, interact with, and render to their environment.

Enter host objects...  A host object "hosts" components which perform discrete tasks, such as positioning and rendering, so that the host doesn't have to perform all of the work.  Or, a host might interact with its components to collect and act upon information from the game's environment.

Some host objects don't even render to the screen.  They might only be there to provide game logic and input...  The possibilities are almost endless.

== Components ==

Like I said, a component is a discrete part of a whole entity.  You can read more about components in the HostComponents section.  For the sake of this discussion, just know that they perform singular tasks to form the whole.

You might have a power-up which floats about the playfield bouncing off walls, and only collides with the player to grant them a super power.  This object would _host_ transformation, rendering, and collision components.  The host only needs to add each of those components and then tell them how to act.  Some components even have "smarts" which dictate how they operate with little input needed from the host.

== Host Execution ==

Each frame of execution, every host object is processed and all components are executed.  The host object, through its `update()` method, is given the opportunity to modify the actions of its components.  Typically, only transformation (movement) of the host will need to be modified.  The collision component will, typically, automatically notify the host when a collision occurs with something giving the host an opportunity to respond.

Finally, the rendering component will be executed (yes, components are executed in a defined order) and the host will be drawn to the RenderContext.  If your power-up was using an animated sprite, there's no need to even update the frame being displayed as that is done automatically for you.

== Simplicity ==

As you can see, by using components effectivly, complex objects can be built with little coding necessary.  As the component library grows, more and more operations will be automated for usage in the engine.  Additionally, your game can extend components to add simple functionality which make your host object more functional.

In addition to the standard components, a special type of component (known as a host component) performs like a host object.  So, if you were building a ragdoll type object, you might create a torso, head, arm, and leg host object, and then to the ragdoll you would add each host object as a component of the ragdoll.  If you wanted a snake, you might add a few arms in succession to eachother.  The beauty of this is that you only needed to create the arm once, but it will be affected by its parent object.