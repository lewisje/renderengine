# Host Object Components #

As was stated in the EngineProcessOverview, host objects contain components.  Each component performs one specific function.  This allows a host object to segment its processing without having to handle all of the functionality itself.  Each host object need only add components to itself to gain the functionality of that component.  From the example game:
```
   constructor: function(size, position, pWidth, pHeight) {
      // Call the super class' constructor
      this.base("Spaceroid");

      // Add components to move and draw the asteroid
      this.add(Mover2DComponent.create("move"));
      this.add(Vector2DComponent.create("draw"));
      this.add(ColliderComponent.create("collider", Spaceroids.collisionModel));

      // Playfield bounding box for quick checks
      this.pBox = Rectangle2D.create(0, 0, pWidth, pHeight);

      // Set size and position
      this.size = size || 10;
      this.scoreValue = SpaceroidsRock.values[String(this.size)];
      if (!position)
      {
         // Set the position
         position = new Point2D( Math.floor(Math.random() * this.pBox.getDims().x),
                                 Math.floor(Math.random() * this.pBox.getDims().y));
      }
      this.setPosition(position);
   }
```
As you can see, a rock contains three components: one mover, one renderer, and one collider.  By doing so, the rock object doesn't need to be written to position itself or how to move around the playfield, nor does it have to implement the code to render to the context.  We feed each component with information that it needs, and the component does the work for us.  For example, the "draw" component needs to know what points to render and how to render it:
```
setShape: function() {
   var c_draw = this.getComponent("draw");

   // Pick one of the three shapes
   var tmp = [];
   tmp = SpaceroidsRock.shapes[Math.floor(Math.random() * 3)];

   // Scale the shape
   var s = [];
   for (var p = 0; p < tmp.length; p++)
   {
      var pt = Point2D.create(tmp[p][0], tmp[p][1]);
      pt.mul(this.size);
      s.push(pt);
   }

   // Assign the shape to the vector component
   c_draw.setPoints(s);
   c_draw.setLineStyle("white");
   c_draw.setLineWidth(0.5);
}
```
We refer to components by a unique name, assigned when we added the component to the host object.  We cannot have two components with the same name, however we _can_ have two components of the same type as long as the names are different.

Once we get the component, we can call its methods to set it up.  From that point on, we don't really need to do anything unless we want to modify how it behaves.  In this case, we're done.  We only needed to set the points, tell it the color, and set the line width.  The "move" component will handle all of the positioning and rotation.  See how this works?  Pretty cool, eh?

## Callback Components ##

Some components need to interact with the host object.  Those components will call methods defined on your host object.  The component defines the method name, or names, that your host object must implement.  If you don't implement the method, don't worry... Components will check for a method's existence before trying to call it.  By implementing callbacks this way, you can selectively determine what parts of some components to utilize.

The rock object has one method that it needs to implement for the collider component to be effective.  The method, as long as it is defined, will be called by the component whenever it needs to update the host object.  In this case, the rock needs to know if it has collided with the player object:
```
   onCollide: function(obj) {
      if (obj instanceof SpaceroidsPlayer &&
          (Math2D.boxBoxCollision(this.getWorldBox(), obj.getWorldBox())))
      {
         if (obj.isAlive())
         {
            obj.kill();
            this.kill();

            // Tell the collider component to stop
            return ColliderComponent.STOP;
         }
      }

      // Let the collider component know to keep processing
      return ColliderComponent.CONTINUE;
   }
```
Callback methods begin with the "on" prefix so that you know that you are responding to an event generated by a component.  `onCollide()` will be called by the collider component when potential collisions are occurring based on the collision model supplied to the component when it was initialized.  The object which is potentially colliding with the rock object is passed into the method.

It is up to us to determine if the collision is valid or not, and to respond accurately.  Not all callbacks will need a return value.  However, in this case, the collider component needs to know if it should continue checking for collisions this frame, or if we're satisfied that a collision has occurred.

In this example, if the object is an instance of a player object, and that object's bounding box overlaps the rock's bounding box, we say a collision has occurred.  We let the collider component know that it can stop checking for further collisions by passing `ColliderComponent.STOP`.  If this wasn't a valid collision, we tell the collider to continue so it can see if other objects are potentially colliding with the rock.

## Component Inheritance ##

The point of using an object oriented architecture is to allow classes to inherit functionality from some parent class.  For example, the [Mover2DComponent](http://renderengine.googlecode.com/svn/api/Mover2DComponent.html) component inherits from the [Transform2DComponent](http://renderengine.googlecode.com/svn/api/Transform2DComponent.html) component.  The reason for this is that `Transform2DComponent` implements position, rotation, and scaling.  The `Mover2DComponent` component uses this and adds time based movement.  `Transform2DComponent` only stores a single position, rotation, and scale which is where `Mover2DComponent` comes in.

`Mover2DComponent` inherits from `Transform2DComponent` to gain access to those values, but adds the ability to update the single position based on velocity, and update the rotation based on angular velocity, each and every frame.  Many other components in the system extend existing components to gain access to their methods and provide layered functionality.  You may find yourself in a situation where an existing component provides 99% of what you need.  In that case, extending the component is your best option.  That will save you time in the long run.

Rather than modifying an existing engine component, or placing your own components in the `/components/` folder, you can put them into your game's folder.  That way, if the engine is updated with new features or bug fixes, you can upgrade the engine without losing your own objects and also avoid the problem of having to merge code.

## Components Example ##

[Tutorial 2](http://www.renderengine.com/tutorials/tutorial2_1.php) on _The Render Engine_ website has more information on the topic.  [Tutorial 3](http://www.renderengine.com/tutorials/tutorial3_1.php) shows multiple components working together in a simple HostObject.